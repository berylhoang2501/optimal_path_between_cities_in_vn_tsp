# -*- coding: utf-8 -*-
"""optimal-path-between-cities-in-vn-tsp.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MGWvcpMaIimC371SruVVp0hW980NYtn7

# <div style="padding:15px;background-color:#d2e9f8; border-radius:20px;margin:0;color:#455a64;border:3px dotted #607d8b;font-family:Charter;font-weight: bold;font-size:130%;text-align:center;overflow:hidden;font-weight:500">Optimal Path Between Cities In VietNam (TSP)</div>

- This notebook presents a solution for the Traveling Salesman Problem (TSP) applied to real-world data from cities across Vietnam. The TSP is a renowned challenge in computer science, requiring the determination of the shortest possible route that allows a traveler to visit a specified set of cities and return to the starting point. This problem holds significant practical value, particularly in the domains of logistics and transportation planning.

- In this notebook, we explore a dataset comprising cities in Vietnam, employing a blend of mathematical optimization techniques and heuristic methods to identify the optimal route among them. We begin by loading and preprocessing the dataset, which includes the coordinates and names of the cities. Subsequently, we implement a simulated annealing algorithm to derive an optimal solution.

- The results are then visualized using mpl_toolkits, followed by a discussion of insights and conclusions regarding the optimal path between these cities. This notebook serves as a comprehensive guide to solving the TSP with real-world data from Vietnam, providing a valuable reference for future research and development in this field.

# <div style="padding:15px;background-color:#d2e9f8; border-radius:20px;font-family:Charter;color: #455a64;font-weight: bold;font-size:100%;text-align:center;overflow:hidden;font-weight:500">Importing Main Libraries</div>
"""

import pandas as pd # for data manipulation
import numpy as np # for linear algebra
import matplotlib.pyplot as plt # for plotting

from google.colab import drive
drive.mount('/content/drive')

"""# <div style="padding:15px;background-color:#d2e9f8; border-radius:20px;font-family:Charter;color: #455a64;font-weight: bold;font-size:100%;text-align:center;overflow:hidden;font-weight:500">Loading Dataset</div>"""

# # Getting path of dataset
# dataset_path = "/content/drive/MyDrive/TTNT/worldcitiespop.csv"

import pandas as pd

file_path = '/content/drive/MyDrive/TTNT/vn_data.py'

# Define a function to load the data from a file
def load_city_data(filepath):
    with open(filepath, 'r') as file:
        lines = file.readlines()

    cities = []
    latitudes = []
    longitudes = []

    for line in lines:
        parts = line.split()
        if len(parts) < 4:  # Skip lines that don't have enough parts
            continue

        try:
            latitude = float(parts[1])
            longitude = float(parts[2])
        except ValueError:
            continue  # Skip lines where latitude/longitude cannot be converted to float

        city_name = " ".join(parts[3:])
        cities.append(city_name)
        latitudes.append(latitude)
        longitudes.append(longitude)

    # Create a DataFrame
    vn_data = pd.DataFrame({
        "City": cities,
        "Latitude": latitudes,
        "Longitude": longitudes
    })

    return vn_data

# Load the data
vn_data = load_city_data(file_path)

# Display the first few rows of the DataFrame
vn_data.head()

"""# <div style="padding:15px;background-color:#d2e9f8; border-radius:20px;font-family:Charter;color: #455a64;font-weight: bold;font-size:100%;text-align:center;overflow:hidden;font-weight:500">Preprocessing</div>

### Printing Shape of Data
"""

# Printing shape of dataframe
vn_data.shape

"""There are 32 records of largest cities in vn. ->> add more 32 cities

### Checking Number of Missing Values
"""

# Checking number of missing values
vn_data.isna().sum()

"""There are no missing values.

### Checking the Number of Duplicated Records
The names of cities can repeat, but if the whole row repeats then there is something wrong.
"""

# Checking the number of identical records
vn_data.duplicated().sum()

"""There are 0 duplicated records.

### Splitting Data and Converting to Numpy
"""

# Selecting data from a dataframe
cities_coordinates = vn_data.loc[:,['Latitude', 'Longitude']].to_numpy()

# Selecting names of cities from dataframe
cities_names = vn_data.loc[:,['City']].to_numpy()

# Printing first 10 rows of cities_coordinates
cities_coordinates[:10]

"""### Plotting Cities"""

import plotly.express as px
import pandas as pd


# Creating a scatter plot using Plotly
fig1 = px.scatter_mapbox(vn_data, lat="Latitude", lon="Longitude", hover_name="City", zoom=3, height=600, size_max=8)

# Customizing the map style
fig1.update_layout(mapbox_style="carto-positron")

# Showing the interactive plot
fig1.show()

"""# <div style="padding:15px;background-color:#d2e9f8; border-radius:20px;font-family:Charter;color: #455a64;font-weight: bold;font-size:100%;text-align:center;overflow:hidden;font-weight:500">Finding Optimal Path</div>

### Installing Library for Solving TSP
"""

# Installing TSP solving Algorythms
!pip install python-tsp

"""### Adding first city to the end of array to create a loop"""

# Getting first row
first_city = cities_coordinates[0,:]
first_name = cities_names[0,:]

# Printing first row
first_city
first_name

# Adding first_row at the end of cities_coordinates
cities_coordinates = np.vstack((cities_coordinates, first_city))
cities_names = np.vstack((cities_names, first_name))

# Printing coordinates of last city
cities_coordinates[-1]

"""### Creating Distance Matrix"""

from python_tsp.distances import great_circle_distance_matrix

# Creating distance matrix containing distance from each point to another
distance_matrix = great_circle_distance_matrix(cities_coordinates)

# Printing distance_matrix and its dimensions
print("matrix dimensions:", distance_matrix.shape,"\n")
print(np.round(distance_matrix[:8,:8]))

"""### Searching for Optimal Path Using Genetic Algorithm"""

from python_tsp.heuristics import solve_tsp_simulated_annealing

# Using simulated annealing to solve TSP
permutation, distance = solve_tsp_simulated_annealing(distance_matrix)

print("Distance of path in kilometers =", np.round(distance/1000, 2))

"""### Getting the Results"""

# Getting the path
best_path = cities_coordinates[permutation]

import plotly.graph_objects as go
import pandas as pd

fig2 = px.scatter_mapbox(vn_data, lat="Latitude", lon="Longitude", hover_name="City", zoom=3, height=600, size_max=8)

# Adding the best path or solution as a line
fig2.add_trace(go.Scattermapbox(
    lat=best_path[:, 0],
    lon=best_path[:, 1],
    mode='markers+lines',
    name='Best Path',
    marker=go.scattermapbox.Marker(size=4),
    line=go.scattermapbox.Line(width=1,color='steelblue')))

# Customizibg the map style
fig2.update_layout(mapbox_style="carto-positron")

# Showing the interactive plot
fig2.show()

# Getting the cities order
solution = cities_names[permutation]

# Printing the cities order
solution

"""# <div style="padding:15px;background-color:#d2e9f8; border-radius:20px;font-family:Charter;color: #455a64;font-weight: bold;font-size:100%;text-align:center;overflow:hidden;font-weight:500">Conclusion</div>

In this Kaggle notebook, we explored the Traveling Salesman Problem (TSP) using real-world data of cities in the United States. We started by loading and preprocessing the data, selecting only the cities in the US with a population higher than the median. We then created a distance matrix using the great circle distance formula and used the simulated annealing algorithm from the python_tsp library to find an optimal path between the cities.

It is important to note that while the simulated annealing algorithm used in this notebook can provide high-quality solutions, it does not guarantee an optimal solution. The optimal solution can only be guaranteed by using an exact algorithm, which would involve computing all possible permutations of the cities. However, the number of possible permutations is equal to the factorial of the number of cities, making it computationally infeasible for larger instances.

Another important point is that due to the large number of cities in the dataset, it was not feasible to use the entire dataset for the analysis. The amount of RAM required to store the distance matrix for the entire world was too high, so the analysis was limited to cities in the United States.

The final results show the best path that connects the selected cities in the US, plotted on an interactive map using the plotly library. It's important to note that the path we get is not necessarily the shortest possible path, as we used a heuristic algorithm to find an approximate solution. To find the exact shortest path, we would need to use an exact algorithm, which can be computationally expensive for larger instances.

In conclusion, this notebook serves as a comprehensive guide to solving TSP with real-world data, providing insights and conclusions about the optimal path between cities in the United States. It can be used as a reference for further research and development in this field.
"""